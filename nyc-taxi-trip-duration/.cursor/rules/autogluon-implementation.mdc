# AutoGluon実装ガイド

## 基本設定
```python
from autogluon.tabular import TabularPredictor
from autogluon.timeseries import TimeSeriesPredictor
```

## 回帰タスク（滞在時間予測）
```python
# 基本設定
predictor = TabularPredictor(
    label='trip_duration',  # 予測対象
    eval_metric='root_mean_squared_error',
    quantile_levels=[0.8, 0.95]  # 分位予測を有効化
)

# 学習
predictor.fit(
    train_data,
    presets='best_quality',
    time_limit=3600  # 1時間制限
)
```

## 時系列予測（SOC推移予測）
```python
# 時系列設定
predictor = TimeSeriesPredictor(
    target='SOC',
    prediction_length=24,  # 24時間先まで予測
    eval_metric='RMSE'
)

# 学習
predictor.fit(
    train_data,
    presets='best_quality',
    time_limit=3600
)
```

## 特徴量エンジニアリング

### 時刻情報の特徴抽出
```python
# 時間帯特徴量
df['hour'] = df['timestamp'].dt.hour
df['day_of_week'] = df['timestamp'].dt.dayofweek
df['month'] = df['timestamp'].dt.month
df['is_weekend'] = df['day_of_week'].isin([5, 6])

# 時間帯カテゴリ
df['time_period'] = pd.cut(df['hour'], 
                          bins=[0, 6, 12, 18, 24], 
                          labels=['night', 'morning', 'afternoon', 'evening'])
```

### 位置情報のクラスタリング
```python
from sklearn.cluster import KMeans

# 位置情報クラスタリング
coords = df[['latitude', 'longitude']].dropna()
kmeans = KMeans(n_clusters=10, random_state=42)
df['location_cluster'] = kmeans.fit_predict(coords)
```

### 履歴情報の集約
```python
# ユーザー別履歴統計
user_stats = df.groupby('user_id').agg({
    'trip_duration': ['mean', 'std', 'count'],
    'distance': ['mean', 'std']
}).reset_index()
```

## 分位予測の活用

### 予測と分位取得
```python
# 予測実行
predictions = predictor.predict(test_data)

# 分位予測値取得
quantile_80 = predictor.predict(test_data, quantile_levels=[0.8])
quantile_95 = predictor.predict(test_data, quantile_levels=[0.95])

# 安全マージン付き予測
safe_prediction = quantile_80  # 業務判断用
```

### 評価指標
```python
# 精度評価
mae = predictor.evaluate(test_data, silent=True)
print(f"MAE: {mae}")

# pinball loss（分位予測の評価）
from autogluon.tabular.metrics import pinball_loss
pinball_score = pinball_loss(y_true, y_pred_quantile, quantile=0.8)
```

## 業務適用時の注意点

### 安全マージン設計
- **p80分位**: 通常の業務判断用
- **p95分位**: リスク回避が必要な場合
- **予測区間**: [p5, p95]で不確実性を表現

### シミュレーション評価
```python
# 早戻り率計算
early_return_rate = (actual_time < predicted_time * 0.8).mean()

# 過剰充電率計算
overcharge_rate = (actual_time > predicted_time * 1.2).mean()
```

## ベストプラクティス
1. **データ前処理**: 欠損値、異常値の適切な処理
2. **特徴量選択**: 相関の高い特徴量の除去
3. **時間制限**: 学習時間の適切な設定
4. **検証**: ホールドアウト検証の実施
5. **解釈性**: SHAP値による特徴量重要度の確認
description:
globs:
alwaysApply: false
---
